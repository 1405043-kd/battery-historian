// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"github.com/google/battery-historian/bugreportutils"
	"github.com/google/battery-historian/parseutils"
	"github.com/google/battery-historian/analyzer/analyzerCSV"

)

var (
	summaryFormat = flag.String("summary", parseutils.FormatBatteryLevel, "1. batteryLevel 2. totalTime")
	inputDir         = flag.String("inputDir", "", "A bug report or a battery history file generated by `adb shell dumpsys batterystats -c --history-start <start>`")
	outputDir       = flag.String("outputDir", "", "Output filename to write csv data to.")
	//csvFile       = flag.String("csv", "", "Output filename to write csv data to.")
	//scrubPII      = flag.Bool("scrub", true, "Whether ScrubPII is applied to addresses.")
	//multiple      = flag.Bool("multiple", false, "If true, generates the combined results from multiple bugreports. In this case input should be a directory containing bugreports.")
)

func usage() {
	fmt.Println("Incorrect summary argument. Format: --summary=[batteryLevel|totalTime] [--csv=<csv-output-file>]")
	fmt.Println("Single report: --input=<report-file>")
	fmt.Println("Multiple reports: --input=<report-directory> --multiple")
	os.Exit(1)
}

func checkFlags() {
	switch *summaryFormat {
	case parseutils.FormatBatteryLevel:
	case parseutils.FormatTotalTime:
	default:
		usage()
	}

	if *inputDir == "" {
		usage()
	}
}

// processFile processes a single bugreport file, and returns the parsing result as a string.
// Writes csv data to csvWriter if a csv file is specified.
func processFiles(inputDir string, outputDir string) string {

	// Read the whole file
	//directoryName := "F:/bugreports"
	directoryName :=inputDir
	if string(outputDir[len(outputDir)-1])!="/"{
		outputDir= outputDir+"/"
	}

	bugZips, err := ioutil.ReadDir(directoryName)
	if err != nil {
		log.Fatal(err)
	}
	//added new kanak/

	fs := make(map[string]analyzerCSV.UploadedFile)
	var counterGlobal int64=0
	var fileNameCSV string=""
	for _, b_f := range bugZips {
		counterGlobal++
		log.Println(b_f.Name())
		//debugDone//ca, err := ioutil.ReadFile(directoryName + "/" + f.Name())
		//debugDone//Print(err)
		//debugDone//log.Print(ca)


		//files, err := bugreportutils.Contents(part.FileName(), b)
		//debugCOmment//filePath:="C:/adb/bugreport-N2G47H-2018-04-22-23-47-36.zip"
		filePath:=directoryName + "/" + b_f.Name()
		b, _ := ioutil.ReadFile(filePath)
		//log.Print(b)
		files, err := bugreportutils.Contents(b_f.Name(), b)
		fileNameCSV = b_f.Name()
		//log.Print(files)
		//br, files, err := bugreportutils.ExtractBugReport(filePath, b)
		//log.Print(br)



		if err != nil {
			log.Print("failed to read file contents: %v", err)
			return err.Error()
		}

		var contents []byte
		valid := false
		fname := ""

		contentLoop:
			for n, f := range files {
				if bugreportutils.IsBugReport(f) {
					// TODO: handle the case of additional kernel and power monitor files within a single uploaded file
					valid = true
					contents = f
					fname = n
					break contentLoop
				}
			}

			if !valid {
				log.Print("does not contain a valid %s file", fname)
				return "not valid error"
			}


			fs["bugreport"] = analyzerCSV.UploadedFile{"bugreport", fname, contents}



			analyzerCSV.AnalyzeAndResponse(fs, counterGlobal, fileNameCSV, outputDir)



	}


	return "csv generation succeeded"
		///adeed blocks end here
		//







	//
	//if err != nil {
	//	log.Fatal(err)
	//}
	//br, fname, err := bugreportutils.ExtractBugReport(filePath, c)
	//if err != nil {
	//	log.Fatalf("Error getting file contents: %v", err)
	//}
	//fmt.Printf("Parsing %s\n", fname)
	//
	//writer := ioutil.Discard
	//if csvWriter != nil && *summaryFormat == parseutils.FormatTotalTime {
	//	writer = csvWriter
	//}
	//
	//pkgs, errs := packageutils.ExtractAppsFromBugReport(br)
	//if len(errs) > 0 {
	//	log.Printf("Errors encountered when getting package list: %v\n", errs)
	//}
	//upm, errs := parseutils.UIDAndPackageNameMapping(br, pkgs)
	//if len(errs) > 0 {
	//	log.Printf("Errors encountered when generating package mapping: %v\n", errs)
	//}
	//rep := parseutils.AnalyzeHistory(writer, br, *summaryFormat, upm, *scrubPII)
	//
	//// Exclude summaries with no change in battery level
	//var a []parseutils.ActivitySummary
	//for _, s := range rep.Summaries {
	//	if s.InitialBatteryLevel != s.FinalBatteryLevel {
	//		a = append(a, s)
	//	}
	//}
	//
	//
	//if rep.TimestampsAltered {
	//	fmt.Println("Some timestamps were changed while processing the log.")
	//}
	//if len(rep.Errs) > 0 {
	//	fmt.Println("Errors encountered:")
	//	for _, err := range rep.Errs {
	//		fmt.Println(err.Error())
	//	}
	//}
	//fmt.Println("\nNumber of summaries ", len(a), "\n")
	//for _, s := range a {
	//	s.Print(&rep.OutputBuffer)
	//}
	//
	//// Write the battery level summary csv to the csvFile specified
	//if csvWriter != nil && *summaryFormat == parseutils.FormatBatteryLevel {
	//	// The dimension header line is only written if the file is the first one in the directory.
	//	parseutils.BatteryLevelSummariesToCSV(csvWriter, &a, isFirstFile)
	//}

//	return rep.OutputBuffer.String()

}

func main() {
	flag.Parse()
	checkFlags()

	//var csvWriter *bufio.Writer
	//if *csvFile != "" {
	//	f, err := os.Create(*csvFile)
	//	if err != nil {
	//		log.Fatal(err)
	//	}
	//	defer f.Close()
	//	csvWriter = bufio.NewWriter(f)
	//	defer csvWriter.Flush()
	//
	//}
	//isFirstFile := true
	//if *multiple {
	//	// Process multiple history files
	//	filepath.Walk(*input, func(filePath string, f os.FileInfo, err error) error {
	//		if filePath == *input {
	//			return nil
	//		}
	//		fmt.Println("Processing ", filePath, "...")
	//		result := processFiles(filePath, csvWriter, isFirstFile)
	//		fmt.Println(result)
	//		isFirstFile = false
	//		return nil
	//	})
	//} else {


	log.Print(*inputDir)
	log.Print(*outputDir)
	result := processFiles(*inputDir, *outputDir)
	fmt.Println(result)
	//}
}
